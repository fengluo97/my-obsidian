分布式消息中间件


# 一、基本术语

消息：通信交互的载体，是按照编码格式封装的传输数据。

主题：表示一类消息的集合，是一个逻辑概念，可用于区分不同的业务场景

队列：主题由一个或者多个队列组成，当消息发往某一个主题时需选择一个队列

偏移量：消息追加到主题的队列后会分配一个数值，即该队列的第几条消息，该数值即偏移量

发送组：多个发送者用同一个组名表示，可通过命令行查询一个发送组下有多少个发送者，以及常用于事务消息的回调

---

消费组：消费组用于订阅主题消费消息，可以订阅多个主题。一个消费者组可以包含多个消费者。消费者可以是同一个进程中的多个消费组线程、多个消费组进程、部署的多个节点等。

广播模式：同一个消费组内的所有消费者都会消费订阅主题的所有消息，即一条消息会被该消费组的所有消费者收到。

集群模式：同一个消费组内的所有消费者只消费订阅主题的一部分消息，即一条消息只会被该消费组的一个消费者消费。

消费位移：当消费组消费消息时会记录消费的位置，以消费组为单位记录。

并发消费：同一队列的消息由多线程消费且不保证消息的顺序

顺序消费：保证同一队列的消息按顺序消费

消息回溯：RocketMQ 支持按时间回溯，已经消费过的数据可以重新消费，也可以跳过一些积压的消息。

# 二、架构设计
![[Pasted image 20231113223515.png]]
NameServer 提供路由注册与发现功能。无状态，可集群部署，节点之间互相不通信，每个节点通过最终一致性记录完整的路由信息。
Broker 提供消息存储服务。


# 三、典型使用场景

## 消息通道
在不同的服务之间进行消息通信，服务之间的调用不再耦合，通过主题和消费组实现异步解耦。

异步：上游系统不必等待下游服务的返回，能提高服务的相应能力。
解耦：上游系统不必担心下游服务的不稳定会造成拖累。

## 削峰填谷
通过 RocketMQ 承载瞬时高并发的流量，消费服务根据自身消费能力去处理请求，对于消费服务来说，系统负载是相对均衡的。

## 顺序消费场景
RocketMQ 支持队列内有序，在 producer 发送消息时，通过一个可以标识的属性选择队列来达到顺序消费的效果。

## 广播消费场景
通过广播模式，广播模式中的每个消费者都会收到所有的消息。

## 事务消息场景
举个例子，在发送消息之后，还有对数据库的修改操作，此时可通过事务消息来确保不会发生事务问题导致数据不一致，使用事务消息时，第一次发送的是 暂时不可消费的半事务消息；当数据库操作成功后，再发起第二次提交；提交成功后，该消息才会变成可消费，从而保证数据的一致性。



