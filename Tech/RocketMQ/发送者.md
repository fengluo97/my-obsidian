# 一、消息发送 API

![[Pasted image 20231113235952.png]]

DefaultMQProducer 实现了 MQProducer 接口，MQProducer 继承了 MQAdmin 接口。
MQProducer 是消息发送接口，MQAdmin 是集群管理基础接口，ClientConfig 类是客户端配置类。


## 1、发送接口分类

按照发送方式
- 同步发送
- 异步发送：异步回调发送结果
- 一次发送：无结果返回

按一次发送消息数量分类
- 单条消息发送
- 批量消息发送

按照是否指定队列发送
- 随机选择发送
- 指定特定消息队列
- 自定义消息队列选择器


# 二、重要参数以及实战建议

## 1、发送重试机制

实际环境中，网络抖动、集群抖动的情况比较常见，引起抖动的原因也很多，不同机房之间的专线抖动、集群瞬时流量过大等，都可能导致某次消息发送失败。为了应对这种情况，RocketMQ 提供了发送重试机制。

sendMsgTimeout、retryTimesWhenSendFailed、retryTimesWhenSendAsyncFailed

重试机制：当同步/异步发送失败之后，会在发送超时时间内进行不超过重试次数的重试，默认消息发送超时时间为 3 秒，默认重试次数为 2 次，也就是说，发送失败之后，会在 3 秒内进行 2 次重试，如果超过 3 秒，即使没有重试到 2 次也不再进行重试。

最佳实践：建议将 发送超时时间 和 重试次数 设置大一点，以便有足够的重试次数来应对发送失败的场景。比如超时时间设置为 10 秒，重试次数设置为 16 次。
在对调用时长敏感的情况下，可以使用异步发送，并在回调函数中处理发送结果。

## 2、延迟故障规避

其实，RocektMQ 发送已经默认具备了故障规避机制，在发送者向某一个 broker 发送消息失败之后，就会在下一次重试时选择其他 broker 尝试发送。

sendLatencyFaultEnable，延迟故障规避开关
- false：消息发送失败后，会在重试中规避当前 broker-a，但是下一次发送消息还是向 broker-a 发送。相当于乐观规避。
- true：消息发送失败后，会在重试中规避当前 broker-a，并且在接下来一段时间内所有的客户端都不会向 broker-a 发送消息。相当于悲观规避。

最佳实践：不建议开启，集群负载过高的场景下，会增加其他 broker 节点的压力。

## 3、同步发送还是异步发送

每一个消息发送者实例（DefaultMQProducer）内部都会创建一个异步消息发送线程池，默认线程数量为 CPU 核数，其内部有一个有界队列，默认长度为 50000。

客户端通过线程池将消息发送到服务端，服务端处理完成之后返回结果，并根据是否发生异常，调用 SendCallBack 回调函数。

通常没必要使用异步发送。

## 4、发送队列选择

RocketMQ 的消息发送默认采用的是轮询策略，但是也可以通过传入一个自定义的队列选择器来实现自定义队列选择。进而实现顺序消费，但是在发送时也要关注到队列的均衡问题。避免某些队列堆积消息过多。

其次，如果使用了 MessageQueueSelector，那么消息发送的重试机制将会失效，

## 5、指定Key 与 指定 tag 发送

RocketMQ  支持多种消息查询机制，



























# 如何保证一定发送成功？以及服务质量？