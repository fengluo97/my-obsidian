分布式消息中间件

# 一、关键概念

# 主题
表示一类消息的集合，是一个逻辑概念，可用于区分不同的业务场景。
1、合理拆分使用主题，避免粒度过粗、过细
2、生产环境不开启主题自动创建，避免浪费主题资源
3、单一主题只收发同一类型消息，避免混用

## 消息
通信交互的载体，是按照编码格式封装的传输数据。
1、单条消息不建议承载过多数据，不利用重试
2、消息中转时要做好不可变设计

## 队列
主题由一个或者多个队列组成，当消息发往某一个主题时需选择一个队列。
1、按照实际业务消耗设置队列数量，避免客户端轮询压力过大以及元数据过多

## 生产者
构建并发送消息的实体，定义了发送方式和事务行为。
1、不建议单一进程创建过多生产者，要尽可能实现生产者的复用
2、不建议频繁创建和销毁生产者，导致大量短链接，影响系统性能

## 消费者
接收并处理消息的运行实体。
1、不建议单一进程创建过多消费者，单一进程内同一个消费分组只需要初始化唯一的一个消费者即可
2、不建议频繁创建和销毁消费者，导致大量短链接，影响系统性能

## 消费者组
消费组用于订阅主题消费消息，可以订阅多个主题。一个消费者组可以包含多个消费者。消费者可以是同一个进程中的多个消费组线程、多个消费组进程、部署的多个节点等。包含了与消费者之间的订阅关系。

## 订阅关系
一个订阅关系指的是指定某个消费者分组对于某个主题的订阅。
不同消费者分组对于同一个主题的订阅相互独立，同一个消费者分组对于不同主题的订阅也相互独立。同一消费者分组内的消费者在消费逻辑上必须保持一致，否则会出现消费冲突，导致部分消息消费异常。

## 普通消息
普通消息，无序，并发消费，一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠传输的能力，且对消息的处理时机、处理顺序没有特别要求。建议设置全局唯一业务索引键，方便问题追踪。

## 顺序消息
需要生产顺序性和消费顺序性支持。
- 生产顺序性：单一生产者、串行发送、投递到同一队列
- 消费顺序性：串行消费、有限重试、一处理一应答
建议：串行消费，避免批量消费导致乱序。投递队列尽可能离散，避免导致热点队列，建议按照更细的粒度投递队列。

## 定时/延时消息
定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。

## 事务消息
分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。

事务消息工作机制：
1、生产者将消息发送至 broker 。
2、broker 将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为“暂不能投递”，这种状态下的消息即为半事务消息，又称 half 消息。
3、生产者开始执行本地事务逻辑。
4、生产者根据本地事务执行结果向 broker 提交二次确认结果（Commit或是Rollback），broker 收到确认结果后处理逻辑如下：
- 二次确认结果为Commit：broker 将半事务消息标记为可投递，并投递给消费者。
- 二次确认结果为Rollback：broker 将回滚事务，不会将半事务消息投递给消费者。
5、在断网或者是生产者应用重启的特殊情况下，若 broker 未收到发送者提交的二次确认结果，或 broker 收到的二次确认结果为Unknown未知状态，经过固定时间后，broker 将对消息生产者即生产者集群中任一生产者实例发起消息回查。
6、生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
7、生产者根据检查到的本地事务的最终状态再次提交二次确认，broker 仍按照步骤4对半事务消息进行处理。

## 生产者负载均衡
轮询与自定义队列发送两种负载均衡策略

## 消费者负载均衡

### 消息粒度负载均衡

RocketMQ 5.X 已支持消息粒度负载均衡。消息粒度负载均衡策略中，同一消费者分组内的多个消费者将按照消息粒度平均分摊主题中的所有消息，即同一个队列中的消息，可被平均分配给多个消费者共同消费。消息粒度的负载均衡机制，是基于内部的单条消息确认语义实现的。消费者获取某条消息后，服务端会将该消息加锁，保证这条消息对其他消费者不可见，直到该消息消费成功或消费超时。因此，即使多个消费者同时消费同一队列的消息，服务端也可保证消息不会被多个消费者重复消费。
顺序消费中，消息粒度负载均衡策略还需要保证同一消息组内的消息，按照服务端存储的先后顺序进行消费。不同消费者处理同一个消息组内的消息时，会严格按照先后顺序锁定消息状态，确保同一消息组的消息串行消费。例如队列Queue1中有4条顺序消息，这4条消息属于同一消息组G1，存储顺序由M1到M4。在消费过程中，前面的消息M1、M2被消费者Consumer A1处理时，只要消费状态没有提交，消费者A2是无法并行消费后续的M3、M4消息的，必须等前面的消息提交消费状态后才能消费后面的消息。

### 队列粒度负载均衡

队列粒度负载均衡策略保证同一个队列仅被一个消费者处理，该策略的实现依赖消费者和服务端的信息协商机制，并不能保证协商结果完全强一致。因此，在消费者数量、队列数量发生变化时，可能会出现短暂的队列分配结果不一致，从而导致少量消息被重复处理。

无论是消息粒度负载均衡策略还是队列粒度负载均衡策略，在消费者上线或下线、服务端扩缩容等场景下，都会触发短暂的重新负载均衡动作。此时可能会存在短暂的负载不一致情况，出现少量消息重复的现象。因此，需要在下游消费逻辑中做好消息幂等去重处理。

## 消费重试
消费重试主要解决的是业务处理逻辑失败导致的消费完整性问题，是一种为业务兜底的策略，不应该被用做业务流程控制。

## 死信消息
消息消费异常进行消费重试时，达到最大重试次数后会转为死信状态，broker 会将死信消息保存至指定Topic，方便后续进行业务恢复或回溯。

## 消费进度管理
消息位点（offset）：消息是按到达服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点。任意一个消息队列在逻辑上都是无限存储，即消息位点会从0到Long.MAX无限增加。通过主题、队列和位点就可以定位任意一条消息的位置，消息的最小消费位点和最大消费位点会一直递增变化。
消费位点（ConsumerOffset）：若某条消息被某个消费者消费后直接被删除，则其他订阅了该主题的消费者将无法消费该消息，因此引入了消费位点，当消费组消费消息时会记录消费的位置，以消费组为单位记录。broker 会基于每个消费者分组维护一份消费记录，该记录指定消费者分组消费某一个队列时，消费过的最新一条消息的位点，即消费位点。消费位点一定在最大消息位点和最小消息位点之间。

## 消息流控
消息流控指的是系统容量或水位过高，broker 会通过快速失败返回流控错误来避免底层资源承受过高压力。可能由于存储压力大或者消费能力不足导致。

## 广播模式
同一个消费组内的所有消费者都会消费订阅主题的所有消息，即一条消息会被该消费组的所有消费者收到。

## 集群模式
同一个消费组内的所有消费者只消费订阅主题的一部分消息，即一条消息只会被该消费组的一个消费者消费。

## 消息回溯
RocketMQ 支持按时间回溯，已经消费过的数据可以重新消费，也可以跳过一些积压的消息。

# 二、架构设计
![[Pasted image 20231113223515.png]]
NameServer 提供路由注册与发现功能。无状态，可集群部署，节点之间互相不通信，每个节点通过最终一致性记录完整的路由信息。
Broker 提供消息存储服务。


# 三、典型使用场景

## 消息通道
在不同的服务之间进行消息通信，服务之间的调用不再耦合，通过主题和消费组实现异步解耦。

异步：上游系统不必等待下游服务的返回，能提高服务的相应能力。
解耦：上游系统不必担心下游服务的不稳定会造成拖累。

## 削峰填谷
通过 RocketMQ 承载瞬时高并发的流量，消费服务根据自身消费能力去处理请求，对于消费服务来说，系统负载是相对均衡的。

## 顺序消费场景
RocketMQ 支持队列内有序，在 producer 发送消息时，通过一个可以标识的属性选择队列来达到顺序消费的效果。

## 广播消费场景
通过广播模式，广播模式中的每个消费者都会收到所有的消息。

## 事务消息场景
举个例子，在发送消息之后，还有对数据库的修改操作，此时可通过事务消息来确保不会发生事务问题导致数据不一致，使用事务消息时，第一次发送的是 暂时不可消费的半事务消息；当数据库操作成功后，再发起第二次提交；提交成功后，该消息才会变成可消费，从而保证数据的一致性。



