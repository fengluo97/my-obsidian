# 索引
一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

## 数据页简介
在 InnoDB 中，我们可以把用于存放记录的页称为数据页或者索引页（InnoDB 基于聚簇索引存放表数据）。各个数据页组成一个双向链表（File Header），每个数据页中的记录都会按照主键值从小到大的顺序组成一个单向链表（User Records），通过页目录在一个页内快速根据主键值快速查找一个记录（Page Directory）。一个数据页可以被划分为一下七个部分：
- File Header：表示页的一些通用信息，包括上一页、下一页等。
- Page Header：表示数据页专有的一些信息。
- Infimum + Supermum：两个虚拟的伪记录，分别表示页中的最小记录和最大记录。
- User Records：真正存储我们插入的数据记录，按照主键值从小到大的顺序组成一个单向链表。
- Free Space：页中尚未使用的空闲部分。
- Page Directory：相当重要的组成部分，存储页中某些记录的相对位置，也就是各个槽对应的记录在页面中的地址偏移量。用于在一个数据页内根据主键值使用二分法快速查询记录所在的槽，然后在槽中通过记录的 next_record 属性遍历该槽所包含的记录，直到查找到为止。
- File Trailer：用于校验页是否完整，防止页在刷盘时只被刷新了部分。


# 索引的数据结构
## Hash
优点：通过hash映射可以在 O(1) 时间获取对应记录
缺点：需要处理hash冲突，不能很好的支持排序和范围查询

![[Pasted image 20231207234308.png]]

## 二叉查找树（二叉搜索树）
缺点：容易造成树倾斜，存在树退化为线性链表的情况，导致查询变为 O(n)
![[Pasted image 20231207234321.png]]

## AVL 树（平衡二叉查找树）
优点：树的高度稳定，查询复杂度 O(logn)
缺点：维持树的平衡需要较大代价。

## 红黑树（Red Black Tree）
优点：查询复杂度 O(logn)，O(1) 旋转和变色操作，保持大致的树平衡
缺点：大致的平衡导致查询效率不稳定。

关于索引的数据结构选型：索引压根就没法使用二叉树作为数据结构，一定是多叉树。因为二叉树注定了树的高度会随着数据量的增长而增长，导致磁盘IO次数也会随之增长！

## B树（多路平衡查找树）
所有的节点既存放 key 也存放 data，这导致了B树的查询效率不稳定。
所有节点之间相互独立，没有形成双向链表，这导致了B树在进行范围查询时，需要先找到最小值然后对B树进行中序遍历，这就间接的增加了磁盘IO次数。

## B+树（变种多路平衡查找树）
包含了目录项页 + 数据页，其最顶层永远只有一个根节点。
目录项页也就是非叶子节点存储的都是目录项记录，该类型记录包含了主键值和对应页号，只有数据页也就是叶子节点存放了完整的用户记录，包含隐藏列（trx_id等）。

B+树每层的页都是一个双向链表，并按照主键顺序排序。一般为 2到4层，所以通过 B+树可以在4次IO以内查找到对应记录，并且在每个页面内都可以通过二分法快速定位对应记录。
![[Pasted image 20231207234412.png]]

# 索引分类
## 主键索引
数据库表的主键列使用的就是主键索引。
一张表只能有一个主键，并且主键值不能为 null，且不能重复。
在 InnoDB 引擎中，如果没有设置主键，则会查看是否存在唯一索引且不为 null 的字段，选择该字段作为主键，否则会创建一个隐藏列自增主键。

## 聚簇索引
聚簇索引，即索引和数据存放在一起，索引即数据，数据即索引。InnoDB 中的主键索引就属于聚簇索引。
在 MySQL 中，InnoDB 引擎表的 .ibd 文件就包含了该表的索引和数据，非叶子节点存储索引，叶子节点存储数据。

## 非聚簇索引
非聚簇索引，即索引和数据分开存放，索引即索引，数据即数据。MyISAM 中不论是否是主键都是用的是非聚簇索引。
非聚簇索引在使用主键查询时，会在对应的主键索引中查找记录，其叶子节点存储了主键值和数据文件的记录行号（指针），然后去数据文件中查找对应记录。因此相比于聚簇索引的索引即数据，非聚簇索引的主键查询多了一次回表。

缺点：主键查询如果没有使用到覆盖索引，则会导致二次查询（回表）。

![[Pasted image 20231214235458.png]]

## 二级索引（辅助索引）
个人认为也可算做非聚簇索引，反正数据和索引是分开的，需要去聚簇索引根据主键值回表查询。
其中叶子节点存储的数据是主键。

### 唯一索引
唯一索引是一种约束。MySQL 会保证唯一索引的属性列不出现重复的数据，但是**允许数据为 NULL**，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。

### 普通索引
普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。也是我们经常使用的索引。

### 联合索引
使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。
最左前缀匹配：在使用联合索引时，**MySQL** 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成。
MySQL 8.0之后，新增了索引跳跃扫描特性使得最左前缀匹配原则在一些查询条件下不成立。详见下文 8.0 索引特性。

# 索引代价
## 空间上的代价
B+树的每个节点都是一个页面，16KB 大小，一颗很大的 B+树 将会有许多页面组成，会占用很大一片空间。
## 时间上的代价
B+树中的每层节点都按照索引列的值按照从小到大的顺序形成了双向链表，无论是非叶子节点还是叶子节点，其内部记录都按照索引列值从小到大形成了单向链表。因此对数据进行增删改操作时，都需要修改对应的 B+树索引，导致需要额外的时间进行页分裂、页面回收等操作，以维护节点和记录的排序。


# 索引使用分析
## 扫描区间和边界条件
```sql
create table single_table (
	id int not null auto_increment,
	key1 varchar(100),
	key2 int,
	key3 varchar(100),
	key_part1 varchar(100),
	key_part2 varchar(100),
	key_part3 varchar(100),
	common_field varchar(100),
	primary key (id),
	key idx_key1 (key1),
	unique key uk_key2 (key2),
	key idx_key3 (key3),
	key idx_key_part(key_part1, key_part2, key_part3)
) engine=InnoDB charset=uft8
```
后续以此表为例，id 为聚簇索引，key1 建立了二级索引，key2 建立了唯一索引，key3 建立了二级索引，为 key_part1、key_part2、key_part3 建立了联合索引。

**扫描区间**：本次查询中，使用对应的索引进行查询，所扫描的区间。
**边界条件**：把形成这个扫描区间的搜索条件称为边界条件。

全表扫描：从聚簇索引的第一个叶子节点的第一条记录开始，沿着记录所在的单向链表向后扫描，直到最后一个叶子节点的最后一条记录。

举例：
```sql
select * from single_table where id >= 2 and id <= 100;
```
上述语句中，扫描区间为 id 在 \[2, 100\] 之间的记录，形成这个扫描区间的边界条件就是 id >= 2 and id <= 100，并且如果没有这个边界条件，扫描区间就变成了全表扫描。

```sql
select * from single_table where key2 in (1234, 4321) or (key2 >= 10 and key2 <= 20);
```
首先我们可以使用全表扫描的方式来查询，但是我们为 key2 建立了索引，如果使用 uk_key2 索引，那么就相当于从下面三个扫描区间中获取二级索引记录。
- \[1234, 1234\]单点扫描区间：对应的边界条件就是 key2 in (1234)
- \[4321, 4321\]单点扫描区间：对应的边界条件就是 key2 in (4321)
- \[10, 20\]范围扫描区间：对应的边界条件就是 key2 >= 10 and key2 <= 20
由于查询了 \*，所以没有用到覆盖索引，从扫描区间中每获取到一条二级索引记录都需要回表，去聚簇索引中获取完整记录。


## 索引用于排序

## 索引用于分组

## 为什么 limit 会影响执行计划

# 索引相关机制
## 索引下推

## 覆盖索引

## 索引合并

## 索引跳跃扫描

## 什么情况下索引会失效？

# 执行计划，为什么会选错索引？没使用我预期的索引？


# MySQL 8.x 中的索引新特性
索引跳跃扫描
- 隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。
- 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。
- 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。

# 最佳实践

java guide 索引跳跃扫描贡献.


参考文章
[MySQL索引详解 | JavaGuide(Java面试 + 学习指南)](https://javaguide.cn/database/mysql/mysql-index.html)
MySQL 是怎样运行的